---
title: "hashids-内外标识符转换方案"
tags: ["hashids"]
date: 2019-03-13T19:40:03+08:00
draft: false
typora-root-url: ../
---


## 遇到的问题  
有些用户系统，会为用户分配两个唯一标识。一个是内部流转用的，一个是对外展示用的。前者会在中间件和程序中流转，想看到该值的必须条件是有访问权限。后者会出现在需要被人看到、可以口头流转的地方，比如用户账号页面、管理后台、日志打印用户标识。

内外都只用一个标识不行吗？当然可以。demo级别的小玩具或者急于交付的外包项目当然可以这么干。但是一个互联网项目绝对不可以这么做。即便再迫切的想要赶工上线，这些会严重影响后续发展的基础工作也必须要做。这些基础打不牢，轻则需要花费很大的精力去改造升级，重则直接被这些小细节击垮。

为什么要把用户的唯一标识做内外区分呢。原因无非有以下几点：

- 对内标识的设计受数据库存储形式的影响，考虑到性能问题，无论是否是分布式生成的id，一般都会选择用趋势递增的数字做对内标识，而且大概率会在数据库中做主键。将主键暴露在外，一旦黑客攻入内网，直接就可以使用已知id和递增的规律进行攻击。
- 用户存量和用户增长量是公司较为敏感的数据。如果将内部标识暴露在外，友商直接知道了用户存量，早晚各注册一次，又可以知道了每日用户增量。从而制定针对公司不利的策略。
- 有些接口会以递增的用户id做查询条件，如果将内部标识暴露在外，爬虫可以按顺序轻易的爬走用户数据。

## 问题本质

该问题的本质，可以理解成需要满足如下条件的内外标识转换问题：

- 可唯一的进行相互转换
- 仅可在服务端转换
- 对外标识是唯一的、散列的、无序的

最好还要满足以下额外需求

- 有最小散列长度
- 对外的标识可读性要好
- 使用算法而不是对应表的方式解决

## 一些方案

【加随机数】 在对内标志的指定位置增加若干随机数，并在数据库中存储，需要时再进行查库转换。好处：1.处理非常简单。2.转换结果易读；坏处：1.加随机数的位置容易被猜出来。2.使用数据库转换容易变成瓶颈。

【BASE64】将对内标识直接base64做对外标识，直接使用工具类转换。好处：1.处理非常简单。2.转换结果位数少；坏处：1.可直接被反解码。2.得到的对外标识不好读。

【AES】将内部标识使用秘钥对称加密，秘钥存在服务器。好处：1.相对安全。坏处：1.得出的结果位数较长。2.不好读。


## hashids方案  

上面的几种方案在安全、易读、位数少等方面均不能完全满足。这个时候，hashids方案便应运而生了。

> generate short unique ids from integers

如hashids对自己的说明，hashids可以将数字转换为较短的唯一标识。支持的语言非常多。且调用非常方便。详细的介绍可以戳官网 [https://hashids.org/](https://hashids.org/)

其核心思路是：将输入的数字和盐，转换成一个较短的唯一字符串。该字符串可以设定成仅用某些字符。生成的字符串还可以使用盐还原成数字。盐放在服务器端。

## 用法

这里以Java为例。

1.使用maven获取依赖
```xml
<dependency>
    <groupId>org.hashids</groupId>
    <artifactId>hashids</artifactId>
    <version>1.0.3</version>
</dependency>
```
2.加密
```java
// 初始化时设定盐、结果最小长度、映射字符集（最短16位且不能重复）
Hashids hashids = new Hashids("this is my salt", 8, "1234567890ABCDEF");
String hash = hashids.encode(12345L);

// 得到的字符串为
BEB47D7E
```
3.解密
```java
// 初始化设定的参数需要与加密时的保持相同
Hashids hashids = new Hashids("this is my salt", 8, "1234567890ABCDEF");
long[] numbers = hashids.decode("BEB47D7E");

// 解码出来的是数字型数组。注意判空
[ 12345 ]
```
使用就是这么简单，由于本文偏方案选取，具体hashids的使用细节请在官网查看。


## 安全与性能

在安全性上，虽然hashids较AES弱些，但破解起来还是有很高的门槛。且解密出的数据并不是敏感度最高的密码。投入产出比太低。

在性能上，实际测试结果来看，加密十万条仅需要花费120毫秒。无需考虑效率问题。

## 总结

从各方面综合考虑，hashids是解决用户id、订单id内外转换问题的优秀方案。
